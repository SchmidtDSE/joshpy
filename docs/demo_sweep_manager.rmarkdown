---
title: "joshpy Parameter Sweep Demo (SweepManager)"
format: html
execute:
  warning: false
---

```{r}
#| label: setup
#| include: false
library(reticulate)
library(ggplot2)
library(dplyr)
```

## Introduction

[Josh](https://joshsim.org) is an ecological simulation runtime for agent-based
modeling developed by the [Eric and Wendy Schmidt Center for Data Science and Environment](https://github.com/SchmidtDSE/josh).
This demo assumes familiarity with Josh's simulation language and runtime.

**joshpy** is a Python client that enables:

- **Orchestration**: Define parameter sweeps, expand job configurations, and
  execute simulations programmatically
- **Tracking**: Register runs in a DuckDB-backed registry with session and
  config tracking
- **Data Loading**: Import cell-level CSV exports into queryable tables
- **Analysis**: Query results across parameter values and replicates
- **Diagnostics**: Quick matplotlib visualizations for simulation sanity checks
- **Visualization**: Create publication-quality plots with R/ggplot2 integration

This demo walks through a complete parameter sweep workflow **using `SweepManager`**,
which encapsulates the common workflow of expanding, running, and collecting
sweep results. For a more detailed walkthrough using each component directly,
see `demo_manual.qmd`.

We vary the `maxGrowth` parameter from 10 to 100 meters/step across 10 experiments,
each with 3 replicates, then load, query, and visualize the results.

## Prerequisites

Ensure the Josh JAR is available at `jar/joshsim-fat.jar` and joshpy is installed:

```bash
pip install -e '.[all]'
```

For visualization, ensure R is installed with the following packages:

```r
install.packages(c("reticulate", "ggplot2", "dplyr"))
```

## Step 1: Define Parameter Sweep

The first step is to define our experiment configuration. joshpy uses three key
abstractions:

- **`JobConfig`**: The top-level configuration specifying source files, templates,
  and sweep parameters
- **`SweepConfig`**: Defines which parameters to sweep and their values
- **`SweepParameter`**: A single parameter with a name and list of values

```{python}
from pathlib import Path

from joshpy.jobs import JobConfig, SweepConfig, SweepParameter

# Paths to source files
SOURCE_PATH = Path("../examples/hello_cli_configurable.josh")
TEMPLATE_PATH = Path("../examples/templates/sweep_config.jshc.j2")

# Parameter sweep: maxGrowth from 10 to 100 in steps of 10
MAX_GROWTH_VALUES = list(range(10, 101, 10))

config = JobConfig(
    template_path=TEMPLATE_PATH,
    source_path=SOURCE_PATH,
    simulation="Main",
    replicates=3,
    sweep=SweepConfig(
        parameters=[SweepParameter(name="maxGrowth", values=MAX_GROWTH_VALUES)]
    ),
)

print(f"Parameter values: {MAX_GROWTH_VALUES}")
print(f"Replicates per job: {config.replicates}")
print(f"Total runs: {len(MAX_GROWTH_VALUES)} x {config.replicates} = {len(MAX_GROWTH_VALUES) * config.replicates}")
```

Let's examine the source files. The `.josh` file defines the simulation, and
the `.jshc.j2` template provides parameterized configuration:

#### Josh Source

```{python}
print(SOURCE_PATH.read_text())
```

#### Template Configuration

```{python}
print(TEMPLATE_PATH.read_text())
```

Notice that the `.josh` file references `config sweep_config.maxGrowth` - this
pulls the value from our generated config file at runtime.

## Step 2: Create SweepManager

The `SweepManager` encapsulates the entire sweep workflow. It uses a builder
pattern for flexible configuration:

- **`with_registry()`**: Configure DuckDB registry (path or existing instance)
- **`with_cli()`**: Configure JoshCLI (JAR path or existing instance)
- **`build()`**: Expand jobs, create session, and register configurations

```{python}
from joshpy.sweep import SweepManager

# Registry path - saved to disk for use in demo_analysis.qmd
REGISTRY_PATH = "demo_registry.duckdb"

# Create manager with builder pattern
manager = (
    SweepManager.builder(config)
    .with_registry(REGISTRY_PATH, experiment_name="growth_rate_sweep")
    .with_cli(jar_path=Path("../jar/joshsim-fat.jar"))
    .build()
)

print(f"Session ID: {manager.session_id}")
print(f"Jobs: {manager.job_set.total_jobs}")
print(f"Total replicates: {manager.job_set.total_replicates}")

# Show registered job hashes
for job in manager.job_set.jobs:
    print(f"  maxGrowth={job.parameters['maxGrowth']:>3} -> hash={job.run_hash}")
```

## Step 3: Run Simulations

The `run()` method executes all jobs with automatic registry tracking:

```{python}
print("Running 10 experiments (3 replicates each)...\n")

# Run all jobs
results = manager.run()

print(f"\nCompleted: {results.succeeded}/{len(results)} succeeded")

if results.failed > 0:
    print(f"Failed: {results.failed}")
    for job, result in results:
        if not result.success:
            print(f"  maxGrowth={job.parameters['maxGrowth']}: {result.stderr[:100]}...")
```

## Step 4: Load Results

The `load_results()` method automatically discovers export paths from the Josh
file, resolves template variables for each job, and loads CSV results:

```{python}
print("Loading CSV exports into registry...")

rows_loaded = manager.load_results()

print(f"\nLoaded {rows_loaded:,} rows")
```

## Step 5: Verify Data Loaded

Let's verify the data is in the registry and ready for analysis:

```{python}
# Get summary of loaded data
summary = manager.registry.get_data_summary()
print(summary)
```

```{python}
print(f"Export variables: {manager.registry.list_export_variables()}")
print(f"Config parameters: {manager.registry.list_config_parameters()}")
```

## Next Steps: Analysis

Now that data is loaded, see **`demo_analysis.qmd`** for comprehensive coverage of:

- **Diagnostic Plots** (`SimulationDiagnostics`) - quick matplotlib visualizations
- **Custom Queries** (`DiagnosticQueries`) - get pandas DataFrames
- **Direct SQL** - full DuckDB access for advanced analysis
- **R/ggplot2** - publication-quality figures

Quick example using `manager.query()`:

```{python}
# Query with parameter grouping
df = manager.query("averageHeight", group_by="maxGrowth")
print(f"Retrieved {len(df)} rows")
print(df.head(10).to_string(index=False))
```

```{python}
#| label: fig-quick-comparison
#| fig-cap: "Tree height trajectories across maxGrowth values."

from joshpy.diagnostics import SimulationDiagnostics

diag = SimulationDiagnostics(manager.registry)
diag.plot_comparison(
    "averageHeight",
    group_by="maxGrowth",
    title="Tree Height by Growth Rate Parameter",
)
```

## Summary

This demo illustrated the `SweepManager` workflow:

1. **Define** a parameter sweep using `JobConfig` and `SweepConfig`
2. **Build** a `SweepManager` with builder pattern (handles expansion and registration)
3. **Execute** with `manager.run()` - single method replaces manual loops
4. **Load** outputs with `manager.load_results()` - automatic path discovery
5. **Analyze** - see `demo_analysis.qmd` for visualization and queries

**SweepManager Benefits:**

- **Encapsulation**: One object manages registry, CLI, and job set
- **Context manager**: Automatic cleanup with `with` statement
- **Builder pattern**: Flexible configuration with sensible defaults
- **Convenience methods**: `run()`, `load_results()`, `query()` for common operations

**Alternative Creation Methods:**

```python
# From dictionary
manager = SweepManager.from_dict(config.to_dict(), registry=":memory:")

# From YAML file
manager = SweepManager.from_yaml(Path("experiment.yaml"))

# With existing components
manager = (
    SweepManager.builder(config)
    .with_registry(existing_registry, session_id="existing-session")
    .with_cli(existing_cli)
    .build()
)
```

**Related Demos:**

- `demo_manual.qmd` - Step-by-step control using individual components
- `demo_analysis.qmd` - Analysis and visualization (decoupled from orchestration)

## Cleanup

```{python}
# SweepManager cleanup (also works as context manager)
manager.cleanup()  # Remove temporary config files
manager.close()    # Close registry connection
print(f"Cleanup complete. Registry saved to {REGISTRY_PATH}")
print("Run demo_analysis.qmd to explore the results.")
```

**Alternative: Context Manager**

```python
# Automatic cleanup with context manager
with SweepManager.from_dict(config.to_dict()) as manager:
    manager.run()
    manager.load_results()
    df = manager.query("averageHeight", group_by="maxGrowth")
# Resources automatically cleaned up here
```

